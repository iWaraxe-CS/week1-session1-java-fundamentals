package com.coherentsolutions.session1.antipatterns.async;

import java.time.Duration;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\n/**\n * CORRECT PATTERN: Async Programming in Java\n * \n * This class demonstrates the CORRECT way to handle asynchronous operations in Java.\n * Key principles:\n * 1. Use CompletableFuture instead of async/await\n * 2. Compose operations instead of blocking\n * 3. Handle exceptions within the async chain\n * 4. Use proper thread pools instead of creating new threads\n * 5. Implement timeouts and cancellation\n * 6. Use appropriate async patterns for different scenarios\n */\npublic class AsyncCorrect {\n    \n    private static final ExecutorService executor = Executors.newFixedThreadPool(4);\n    private static final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);\n    \n    public static void main(String[] args) {\n        demonstrateCorrectAsync();\n        \n        // Cleanup\n        executor.shutdown();\n        scheduler.shutdown();\n    }\n    \n    public static void demonstrateCorrectAsync() {\n        System.out.println(\"=== CORRECT ASYNC PROGRAMMING PATTERNS ===\");\n        \n        // SOLUTION 1: Proper async composition\n        System.out.println(\"\\n1. Proper async composition:\");\n        demonstrateAsyncComposition();\n        \n        // SOLUTION 2: Exception handling in async chains\n        System.out.println(\"\\n2. Exception handling in async chains:\");\n        demonstrateAsyncExceptionHandling();\n        \n        // SOLUTION 3: Parallel execution\n        System.out.println(\"\\n3. Parallel execution:\");\n        demonstrateParallelExecution();\n        \n        // SOLUTION 4: Timeout handling\n        System.out.println(\"\\n4. Timeout handling:\");\n        demonstrateTimeoutHandling();\n        \n        // SOLUTION 5: Proper resource management\n        System.out.println(\"\\n5. Proper resource management:\");\n        demonstrateResourceManagement();\n        \n        // Give async operations time to complete\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n    \n    public static void demonstrateAsyncComposition() {\n        // ✅ CORRECT: Async composition without blocking\n        \n        CompletableFuture<String> pipeline = fetchDataAsync()\n            .thenCompose(data -> processDataAsync(data))\n            .thenCompose(processed -> saveDataAsync(processed))\n            .thenApply(saved -> \"Final result: \" + saved)\n            .whenComplete((result, throwable) -> {\n                if (throwable != null) {\n                    System.out.println(\"Pipeline failed: \" + throwable.getMessage());\n                } else {\n                    System.out.println(\"Pipeline completed: \" + result);\n                }\n            });\n        \n        System.out.println(\"Async pipeline started (non-blocking)\");\n    }\n    \n    public static void demonstrateAsyncExceptionHandling() {\n        // ✅ CORRECT: Exception handling within async chain\n        \n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n            if (Math.random() > 0.7) {\n                throw new RuntimeException(\"Random failure!\");\n            }\n            return \"Success!\";\n        })\n        .handle((result, throwable) -> {\n            if (throwable != null) {\n                System.out.println(\"Handled exception: \" + throwable.getMessage());\n                return \"Default value\";\n            }\n            return result;\n        })\n        .thenApply(String::toUpperCase)\n        .exceptionally(throwable -> {\n            System.out.println(\"Final exception handler: \" + throwable.getMessage());\n            return \"FALLBACK\";\n        });\n        \n        future.whenComplete((result, throwable) -> {\n            System.out.println(\"Final result: \" + result);\n        });\n    }\n    \n    public static void demonstrateParallelExecution() {\n        // ✅ CORRECT: Running multiple async operations in parallel\n        \n        List<CompletableFuture<String>> futures = Arrays.asList(\n            fetchDataAsync(\"Source 1\"),\n            fetchDataAsync(\"Source 2\"),\n            fetchDataAsync(\"Source 3\")\n        );\n        \n        // Wait for all to complete\n        CompletableFuture<List<String>> allResults = CompletableFuture.allOf(\n            futures.toArray(new CompletableFuture[0])\n        ).thenApply(v -> \n            futures.stream()\n                .map(CompletableFuture::join)\n                .collect(Collectors.toList())\n        );\n        \n        allResults.whenComplete((results, throwable) -> {\n            if (throwable != null) {\n                System.out.println(\"Parallel execution failed: \" + throwable.getMessage());\n            } else {\n                System.out.println(\"All parallel results: \" + results);\n            }\n        });\n        \n        // ✅ CORRECT: Race condition - first one wins\n        CompletableFuture<String> firstResult = CompletableFuture.anyOf(\n            futures.toArray(new CompletableFuture[0])\n        ).thenApply(result -> (String) result);\n        \n        firstResult.whenComplete((result, throwable) -> {\n            System.out.println(\"First result: \" + result);\n        });\n    }\n    \n    public static void demonstrateTimeoutHandling() {\n        // ✅ CORRECT: Adding timeout to async operations\n        \n        CompletableFuture<String> futureWithTimeout = longRunningOperation(\"test\")\n            .orTimeout(2, TimeUnit.SECONDS)\n            .handle((result, throwable) -> {\n                if (throwable instanceof TimeoutException) {\n                    System.out.println(\"Operation timed out\");\n                    return \"Timeout result\";\n                } else if (throwable != null) {\n                    System.out.println(\"Operation failed: \" + throwable.getMessage());\n                    return \"Error result\";\n                }\n                return result;\n            });\n        \n        futureWithTimeout.whenComplete((result, throwable) -> {\n            System.out.println(\"Operation with timeout result: \" + result);\n        });\n        \n        // ✅ CORRECT: Custom timeout implementation\n        CompletableFuture<String> customTimeout = withTimeout(\n            longRunningOperation(\"custom\"),\n            Duration.ofSeconds(1),\n            \"Custom timeout\"\n        );\n        \n        customTimeout.whenComplete((result, throwable) -> {\n            System.out.println(\"Custom timeout result: \" + result);\n        });\n    }\n    \n    public static void demonstrateResourceManagement() {\n        // ✅ CORRECT: Using proper thread pools\n        \n        List<CompletableFuture<String>> tasks = Arrays.asList(\n            CompletableFuture.supplyAsync(() -> processTask(1), executor),\n            CompletableFuture.supplyAsync(() -> processTask(2), executor),\n            CompletableFuture.supplyAsync(() -> processTask(3), executor),\n            CompletableFuture.supplyAsync(() -> processTask(4), executor)\n        );\n        \n        CompletableFuture<Void> allTasks = CompletableFuture.allOf(\n            tasks.toArray(new CompletableFuture[0])\n        );\n        \n        allTasks.whenComplete((v, throwable) -> {\n            if (throwable != null) {\n                System.out.println(\"Some tasks failed: \" + throwable.getMessage());\n            } else {\n                System.out.println(\"All tasks completed successfully\");\n                tasks.forEach(task -> {\n                    try {\n                        System.out.println(\"Task result: \" + task.get());\n                    } catch (Exception e) {\n                        System.out.println(\"Task error: \" + e.getMessage());\n                    }\n                });\n            }\n        });\n    }\n    \n    // ✅ CORRECT: Async method that returns CompletableFuture\n    public static CompletableFuture<String> getDataCorrect(String input) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new CompletionException(e);\n            }\n            return \"Processed: \" + input;\n        }, executor);\n    }\n    \n    // ✅ CORRECT: Method with proper timeout handling\n    public static CompletableFuture<String> getDataWithTimeout(String input, Duration timeout) {\n        CompletableFuture<String> future = longRunningOperation(input);\n        \n        return future\n            .orTimeout(timeout.toMillis(), TimeUnit.MILLISECONDS)\n            .exceptionally(throwable -> {\n                if (throwable.getCause() instanceof TimeoutException) {\n                    return \"Operation timed out after \" + timeout.toSeconds() + \" seconds\";\n                }\n                return \"Operation failed: \" + throwable.getMessage();\n            });\n    }\n    \n    // ✅ CORRECT: Cancellable long-running operation\n    public static CompletableFuture<String> startCancellableLongRunningTask() {\n        return CompletableFuture.supplyAsync(() -> {\n            for (int i = 0; i < 1000000; i++) {\n                // ✅ CORRECT: Check for interruption\n                if (Thread.currentThread().isInterrupted()) {\n                    throw new CompletionException(new InterruptedException(\"Task was cancelled\"));\n                }\n                \n                // Simulate work\n                if (i % 100000 == 0) {\n                    System.out.println(\"Processing: \" + i);\n                }\n            }\n            return \"Long task completed\";\n        }, executor);\n    }\n    \n    // ✅ CORRECT: Async file reading (simulated)\n    public static CompletableFuture<String> readFileAsync(String filename) {\n        return CompletableFuture.supplyAsync(() -> {\n            // In real scenario, use async I/O libraries like NIO.2\n            try {\n                // Simulate async file reading\n                Thread.sleep(100);\n                return \"File content: \" + filename;\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new CompletionException(e);\n            }\n        }, executor);\n    }\n    \n    // ✅ CORRECT: Retry mechanism for async operations\n    public static CompletableFuture<String> retryableOperation(String input, int maxRetries) {\n        return retryAsync(() -> unreliableOperation(input), maxRetries);\n    }\n    \n    // ✅ CORRECT: Circuit breaker pattern\n    public static CompletableFuture<String> circuitBreakerOperation(String input) {\n        if (CircuitBreaker.isOpen()) {\n            return CompletableFuture.completedFuture(\"Circuit breaker is open\");\n        }\n        \n        return fetchDataAsync(input)\n            .whenComplete((result, throwable) -> {\n                if (throwable != null) {\n                    CircuitBreaker.recordFailure();\n                } else {\n                    CircuitBreaker.recordSuccess();\n                }\n            });\n    }\n    \n    // Helper methods\n    private static CompletableFuture<String> fetchDataAsync() {\n        return fetchDataAsync(\"default\");\n    }\n    \n    private static CompletableFuture<String> fetchDataAsync(String source) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new CompletionException(e);\n            }\n            return \"Fetched data from \" + source;\n        }, executor);\n    }\n    \n    private static CompletableFuture<String> processDataAsync(String data) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(300);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new CompletionException(e);\n            }\n            return \"Processed: \" + data;\n        }, executor);\n    }\n    \n    private static CompletableFuture<String> saveDataAsync(String data) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new CompletionException(e);\n            }\n            return \"Saved: \" + data;\n        }, executor);\n    }\n    \n    private static CompletableFuture<String> longRunningOperation(String input) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(5000); // 5 seconds\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new CompletionException(e);\n            }\n            return \"Long result: \" + input;\n        }, executor);\n    }\n    \n    private static String processTask(int taskId) {\n        try {\n            Thread.sleep(100 * taskId);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new CompletionException(e);\n        }\n        return \"Task \" + taskId + \" completed on \" + Thread.currentThread().getName();\n    }\n    \n    private static CompletableFuture<String> unreliableOperation(String input) {\n        return CompletableFuture.supplyAsync(() -> {\n            if (Math.random() > 0.6) {\n                throw new RuntimeException(\"Unreliable operation failed\");\n            }\n            return \"Reliable result: \" + input;\n        }, executor);\n    }\n    \n    // ✅ CORRECT: Utility methods\n    \n    // Custom timeout implementation\n    public static <T> CompletableFuture<T> withTimeout(CompletableFuture<T> future, \n                                                      Duration timeout, \n                                                      T defaultValue) {\n        CompletableFuture<T> timeoutFuture = new CompletableFuture<>();\n        \n        scheduler.schedule(() -> {\n            timeoutFuture.complete(defaultValue);\n        }, timeout.toMillis(), TimeUnit.MILLISECONDS);\n        \n        return future.applyToEither(timeoutFuture, result -> result);\n    }\n    \n    // Retry mechanism\n    public static <T> CompletableFuture<T> retryAsync(Supplier<CompletableFuture<T>> operation, \n                                                     int maxRetries) {\n        CompletableFuture<T> future = operation.get();\n        \n        for (int i = 0; i < maxRetries; i++) {\n            future = future.exceptionally(throwable -> {\n                System.out.println(\"Retry attempt \" + (maxRetries - i) + \" after failure: \" + \n                    throwable.getMessage());\n                return null;\n            }).thenCompose(result -> {\n                if (result != null) {\n                    return CompletableFuture.completedFuture(result);\n                } else {\n                    return operation.get();\n                }\n            });\n        }\n        \n        return future;\n    }\n    \n    // Debounce mechanism\n    public static <T> CompletableFuture<T> debounce(Supplier<CompletableFuture<T>> operation, \n                                                   Duration delay) {\n        CompletableFuture<T> result = new CompletableFuture<>();\n        \n        scheduler.schedule(() -> {\n            operation.get().whenComplete((value, throwable) -> {\n                if (throwable != null) {\n                    result.completeExceptionally(throwable);\n                } else {\n                    result.complete(value);\n                }\n            });\n        }, delay.toMillis(), TimeUnit.MILLISECONDS);\n        \n        return result;\n    }\n    \n    // Rate limiting\n    public static <T> CompletableFuture<T> rateLimit(Supplier<CompletableFuture<T>> operation, \n                                                    Duration interval) {\n        // Simple rate limiting implementation\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(interval.toMillis());\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new CompletionException(e);\n            }\n            return null;\n        }, scheduler).thenCompose(v -> operation.get());\n    }\n    \n    // Simple circuit breaker\n    private static class CircuitBreaker {\n        private static int failures = 0;\n        private static final int threshold = 5;\n        private static boolean open = false;\n        \n        public static boolean isOpen() {\n            return open;\n        }\n        \n        public static void recordFailure() {\n            failures++;\n            if (failures >= threshold) {\n                open = true;\n                // In real implementation, add timer to reset\n            }\n        }\n        \n        public static void recordSuccess() {\n            failures = 0;\n            open = false;\n        }\n    }\n    \n    // ✅ CORRECT: Async utilities class\n    public static class AsyncUtils {\n        \n        // Safe async execution\n        public static <T> CompletableFuture<T> safeAsync(Supplier<T> supplier) {\n            return CompletableFuture.supplyAsync(() -> {\n                try {\n                    return supplier.get();\n                } catch (Exception e) {\n                    throw new CompletionException(e);\n                }\n            }, executor);\n        }\n        \n        // Delay execution\n        public static CompletableFuture<Void> delay(Duration duration) {\n            CompletableFuture<Void> future = new CompletableFuture<>();\n            scheduler.schedule(() -> future.complete(null), \n                duration.toMillis(), TimeUnit.MILLISECONDS);\n            return future;\n        }\n        \n        // Combine multiple futures\n        public static <T> CompletableFuture<List<T>> combine(List<CompletableFuture<T>> futures) {\n            return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))\n                .thenApply(v -> futures.stream()\n                    .map(CompletableFuture::join)\n                    .collect(Collectors.toList()));\n        }\n        \n        // First successful result\n        public static <T> CompletableFuture<T> firstSuccess(List<CompletableFuture<T>> futures) {\n            CompletableFuture<T> result = new CompletableFuture<>();\n            \n            futures.forEach(future -> \n                future.whenComplete((value, throwable) -> {\n                    if (throwable == null && !result.isDone()) {\n                        result.complete(value);\n                    }\n                })\n            );\n            \n            return result;\n        }\n    }\n}