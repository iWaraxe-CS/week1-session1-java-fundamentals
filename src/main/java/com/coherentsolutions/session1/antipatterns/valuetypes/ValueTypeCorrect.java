package com.coherentsolutions.session1.antipatterns.valuetypes;

import lombok.Value;\nimport lombok.Builder;\nimport lombok.EqualsAndHashCode;\n\nimport java.math.BigDecimal;\nimport java.util.Currency;\nimport java.util.Objects;\n\n/**\n * CORRECT PATTERN: Value Types in Java\n * \n * This class demonstrates the CORRECT way to implement value-like behavior in Java.\n * Key principles:\n * 1. Use immutable objects for value semantics\n * 2. Properly implement equals(), hashCode(), and toString()\n * 3. Use records (Java 14+) for simple value objects\n * 4. Use Lombok @Value for automatic value object implementation\n * 5. Create type-safe wrappers instead of primitive obsession\n * 6. Ensure objects are truly immutable\n */\npublic class ValueTypeCorrect {\n    \n    public static void main(String[] args) {\n        demonstrateCorrectValueTypes();\n    }\n    \n    public static void demonstrateCorrectValueTypes() {\n        System.out.println(\"=== CORRECT VALUE TYPE PATTERNS ===\");\n        \n        // SOLUTION 1: Records for simple value objects\n        System.out.println(\"\\n1. Records for simple value objects:\");\n        demonstrateRecords();\n        \n        // SOLUTION 2: Lombok @Value annotation\n        System.out.println(\"\\n2. Lombok @Value annotation:\");\n        demonstrateLombokValue();\n        \n        // SOLUTION 3: Manual immutable implementation\n        System.out.println(\"\\n3. Manual immutable implementation:\");\n        demonstrateManualImmutable();\n        \n        // SOLUTION 4: Type-safe wrappers\n        System.out.println(\"\\n4. Type-safe wrappers:\");\n        demonstrateTypeSafeWrappers();\n        \n        // SOLUTION 5: Complex value objects\n        System.out.println(\"\\n5. Complex value objects:\");\n        demonstrateComplexValueObjects();\n        \n        // SOLUTION 6: Value objects in collections\n        System.out.println(\"\\n6. Value objects in collections:\");\n        demonstrateCollectionUsage();\n    }\n    \n    public static void demonstrateRecords() {\n        // ✅ CORRECT: Using records (Java 14+)\n        \n        PointRecord p1 = new PointRecord(10, 20);\n        PointRecord p2 = new PointRecord(10, 20);\n        PointRecord p3 = p1; // Reference copy\n        \n        System.out.println(\"p1: \" + p1);\n        System.out.println(\"p2: \" + p2);\n        \n        // ✅ CORRECT: Value equality\n        System.out.println(\"p1.equals(p2): \" + p1.equals(p2)); // true\n        System.out.println(\"p1 == p2: \" + (p1 == p2)); // false (different references)\n        System.out.println(\"p1 == p3: \" + (p1 == p3)); // true (same reference)\n        \n        // ✅ CORRECT: Proper hashCode implementation\n        System.out.println(\"p1.hashCode(): \" + p1.hashCode());\n        System.out.println(\"p2.hashCode(): \" + p2.hashCode());\n        System.out.println(\"Equal objects have same hash code!\");\n        \n        // ✅ CORRECT: Immutability - can't modify\n        // p1.x = 30; // Compilation error - fields are final\n        \n        // ✅ CORRECT: \"Copying\" by creating new instance\n        PointRecord moved = new PointRecord(p1.x() + 10, p1.y() + 10);\n        System.out.println(\"Original: \" + p1);\n        System.out.println(\"Moved: \" + moved);\n    }\n    \n    public static void demonstrateLombokValue() {\n        // ✅ CORRECT: Using Lombok @Value\n        \n        PersonValue person1 = new PersonValue(\"John\", 25);\n        PersonValue person2 = new PersonValue(\"John\", 25);\n        \n        System.out.println(\"person1: \" + person1);\n        System.out.println(\"person2: \" + person2);\n        \n        // ✅ CORRECT: Automatic equals implementation\n        System.out.println(\"person1.equals(person2): \" + person1.equals(person2)); // true\n        \n        // ✅ CORRECT: Automatic hashCode implementation\n        System.out.println(\"person1.hashCode(): \" + person1.hashCode());\n        System.out.println(\"person2.hashCode(): \" + person2.hashCode());\n        \n        // ✅ CORRECT: Immutability\n        // person1.setAge(26); // Compilation error - no setters\n        \n        // ✅ CORRECT: \"Updating\" by creating new instance\n        PersonValue olderPerson = person1.withAge(26);\n        System.out.println(\"Original: \" + person1);\n        System.out.println(\"Older: \" + olderPerson);\n    }\n    \n    public static void demonstrateManualImmutable() {\n        // ✅ CORRECT: Manual immutable implementation\n        \n        ImmutablePoint point1 = new ImmutablePoint(5, 15);\n        ImmutablePoint point2 = new ImmutablePoint(5, 15);\n        \n        System.out.println(\"point1: \" + point1);\n        System.out.println(\"point2: \" + point2);\n        \n        // ✅ CORRECT: Proper value equality\n        System.out.println(\"point1.equals(point2): \" + point1.equals(point2)); // true\n        \n        // ✅ CORRECT: Consistent hashCode\n        System.out.println(\"point1.hashCode(): \" + point1.hashCode());\n        System.out.println(\"point2.hashCode(): \" + point2.hashCode());\n        \n        // ✅ CORRECT: Immutable operations\n        ImmutablePoint translated = point1.translate(10, 5);\n        System.out.println(\"Original: \" + point1);\n        System.out.println(\"Translated: \" + translated);\n    }\n    \n    public static void demonstrateTypeSafeWrappers() {\n        // ✅ CORRECT: Type-safe wrappers instead of primitives\n        \n        Temperature celsius = Temperature.celsius(25);\n        Temperature fahrenheit = Temperature.fahrenheit(77);\n        \n        Money usd = Money.of(100.50, \"USD\");\n        Money eur = Money.of(85.30, \"EUR\");\n        \n        UserId userId = new UserId(\"user-123\");\n        OrderId orderId = new OrderId(\"order-456\");\n        \n        System.out.println(\"Celsius: \" + celsius);\n        System.out.println(\"Fahrenheit: \" + fahrenheit);\n        System.out.println(\"USD: \" + usd);\n        System.out.println(\"EUR: \" + eur);\n        System.out.println(\"User ID: \" + userId);\n        System.out.println(\"Order ID: \" + orderId);\n        \n        // ✅ CORRECT: Type safety prevents errors\n        processTemperature(celsius);\n        processMoney(usd);\n        processUser(userId);\n        \n        // processTemperature(usd); // Compilation error!\n        // processMoney(celsius); // Compilation error!\n        // processUser(orderId); // Compilation error!\n        \n        System.out.println(\"Type safety prevents semantic errors!\");\n    }\n    \n    public static void demonstrateComplexValueObjects() {\n        // ✅ CORRECT: Complex value objects with business logic\n        \n        Address address1 = Address.builder()\n            .street(\"123 Main St\")\n            .city(\"New York\")\n            .state(\"NY\")\n            .zipCode(\"10001\")\n            .country(\"USA\")\n            .build();\n        \n        Address address2 = Address.builder()\n            .street(\"123 Main St\")\n            .city(\"New York\")\n            .state(\"NY\")\n            .zipCode(\"10001\")\n            .country(\"USA\")\n            .build();\n        \n        System.out.println(\"address1: \" + address1);\n        System.out.println(\"address1.equals(address2): \" + address1.equals(address2));\n        \n        // ✅ CORRECT: Business logic in value objects\n        System.out.println(\"Formatted: \" + address1.getFormattedAddress());\n        System.out.println(\"Is US address: \" + address1.isUSAddress());\n        \n        // ✅ CORRECT: Immutable updates\n        Address newAddress = address1.withZipCode(\"10002\");\n        System.out.println(\"Original: \" + address1.getZipCode());\n        System.out.println(\"Updated: \" + newAddress.getZipCode());\n    }\n    \n    public static void demonstrateCollectionUsage() {\n        // ✅ CORRECT: Value objects work properly in collections\n        \n        java.util.Set<PointRecord> pointSet = new java.util.HashSet<>();\n        java.util.Map<PersonValue, String> personMap = new java.util.HashMap<>();\n        \n        PointRecord point1 = new PointRecord(10, 20);\n        PointRecord point2 = new PointRecord(10, 20); // Same values\n        \n        PersonValue person1 = new PersonValue(\"Alice\", 30);\n        PersonValue person2 = new PersonValue(\"Alice\", 30); // Same values\n        \n        // ✅ CORRECT: Adding to collections\n        pointSet.add(point1);\n        pointSet.add(point2); // Won't add duplicate due to proper equals/hashCode\n        \n        personMap.put(person1, \"Person 1\");\n        \n        System.out.println(\"Point set size: \" + pointSet.size()); // 1\n        System.out.println(\"Set contains point1: \" + pointSet.contains(point1)); // true\n        System.out.println(\"Set contains point2: \" + pointSet.contains(point2)); // true\n        \n        System.out.println(\"Map get with person1: \" + personMap.get(person1)); // \"Person 1\"\n        System.out.println(\"Map get with person2: \" + personMap.get(person2)); // \"Person 1\"\n        \n        System.out.println(\"Value objects work correctly in collections!\");\n    }\n    \n    private static void processTemperature(Temperature temp) {\n        System.out.println(\"Processing temperature: \" + temp);\n    }\n    \n    private static void processMoney(Money money) {\n        System.out.println(\"Processing money: \" + money);\n    }\n    \n    private static void processUser(UserId userId) {\n        System.out.println(\"Processing user: \" + userId);\n    }\n    \n    // ✅ CORRECT: Record for simple value object (Java 14+)\n    public record PointRecord(int x, int y) {\n        \n        // ✅ CORRECT: Validation in compact constructor\n        public PointRecord {\n            if (x < 0 || y < 0) {\n                throw new IllegalArgumentException(\"Coordinates must be non-negative\");\n            }\n        }\n        \n        // ✅ CORRECT: Business methods\n        public double distanceFromOrigin() {\n            return Math.sqrt(x * x + y * y);\n        }\n        \n        public PointRecord translate(int dx, int dy) {\n            return new PointRecord(x + dx, y + dy);\n        }\n    }\n    \n    // ✅ CORRECT: Lombok @Value for automatic implementation\n    @Value\n    public static class PersonValue {\n        String name;\n        int age;\n        \n        // ✅ CORRECT: Validation\n        public PersonValue(String name, int age) {\n            if (name == null || name.trim().isEmpty()) {\n                throw new IllegalArgumentException(\"Name cannot be null or empty\");\n            }\n            if (age < 0) {\n                throw new IllegalArgumentException(\"Age cannot be negative\");\n            }\n            this.name = name.trim();\n            this.age = age;\n        }\n        \n        // ✅ CORRECT: \"Wither\" methods for immutable updates\n        public PersonValue withAge(int newAge) {\n            return new PersonValue(this.name, newAge);\n        }\n        \n        public PersonValue withName(String newName) {\n            return new PersonValue(newName, this.age);\n        }\n        \n        // ✅ CORRECT: Business methods\n        public boolean isAdult() {\n            return age >= 18;\n        }\n    }\n    \n    // ✅ CORRECT: Manual immutable implementation\n    public static final class ImmutablePoint {\n        private final int x;\n        private final int y;\n        \n        public ImmutablePoint(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        \n        public int getX() {\n            return x;\n        }\n        \n        public int getY() {\n            return y;\n        }\n        \n        public ImmutablePoint translate(int dx, int dy) {\n            return new ImmutablePoint(x + dx, y + dy);\n        }\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            ImmutablePoint that = (ImmutablePoint) obj;\n            return x == that.x && y == that.y;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n        \n        @Override\n        public String toString() {\n            return \"Point(\" + x + \", \" + y + \")\";\n        }\n    }\n    \n    // ✅ CORRECT: Type-safe temperature\n    @Value\n    public static class Temperature {\n        double value;\n        TemperatureUnit unit;\n        \n        public static Temperature celsius(double value) {\n            return new Temperature(value, TemperatureUnit.CELSIUS);\n        }\n        \n        public static Temperature fahrenheit(double value) {\n            return new Temperature(value, TemperatureUnit.FAHRENHEIT);\n        }\n        \n        public Temperature toCelsius() {\n            if (unit == TemperatureUnit.CELSIUS) {\n                return this;\n            }\n            return celsius((value - 32) * 5.0 / 9.0);\n        }\n        \n        public Temperature toFahrenheit() {\n            if (unit == TemperatureUnit.FAHRENHEIT) {\n                return this;\n            }\n            return fahrenheit(value * 9.0 / 5.0 + 32);\n        }\n        \n        public enum TemperatureUnit {\n            CELSIUS, FAHRENHEIT\n        }\n    }\n    \n    // ✅ CORRECT: Type-safe money\n    @Value\n    public static class Money {\n        BigDecimal amount;\n        String currencyCode;\n        \n        public static Money of(double amount, String currencyCode) {\n            return new Money(BigDecimal.valueOf(amount), currencyCode);\n        }\n        \n        public static Money of(BigDecimal amount, String currencyCode) {\n            return new Money(amount, currencyCode);\n        }\n        \n        public Money add(Money other) {\n            if (!currencyCode.equals(other.currencyCode)) {\n                throw new IllegalArgumentException(\"Cannot add different currencies\");\n            }\n            return new Money(amount.add(other.amount), currencyCode);\n        }\n        \n        public Money multiply(double factor) {\n            return new Money(amount.multiply(BigDecimal.valueOf(factor)), currencyCode);\n        }\n    }\n    \n    // ✅ CORRECT: Type-safe ID classes\n    @Value\n    public static class UserId {\n        String value;\n        \n        public UserId(String value) {\n            if (value == null || value.trim().isEmpty()) {\n                throw new IllegalArgumentException(\"User ID cannot be null or empty\");\n            }\n            this.value = value.trim();\n        }\n    }\n    \n    @Value\n    public static class OrderId {\n        String value;\n        \n        public OrderId(String value) {\n            if (value == null || value.trim().isEmpty()) {\n                throw new IllegalArgumentException(\"Order ID cannot be null or empty\");\n            }\n            this.value = value.trim();\n        }\n    }\n    \n    // ✅ CORRECT: Complex value object with builder\n    @Value\n    @Builder\n    public static class Address {\n        String street;\n        String city;\n        String state;\n        String zipCode;\n        String country;\n        \n        public String getFormattedAddress() {\n            return String.format(\"%s, %s, %s %s, %s\", \n                street, city, state, zipCode, country);\n        }\n        \n        public boolean isUSAddress() {\n            return \"USA\".equalsIgnoreCase(country);\n        }\n        \n        public Address withZipCode(String newZipCode) {\n            return new Address(street, city, state, newZipCode, country);\n        }\n        \n        public Address withStreet(String newStreet) {\n            return new Address(newStreet, city, state, zipCode, country);\n        }\n    }\n    \n    // ✅ CORRECT: Enum for type safety\n    public enum Priority {\n        LOW(1),\n        MEDIUM(2),\n        HIGH(3),\n        CRITICAL(4);\n        \n        private final int level;\n        \n        Priority(int level) {\n            this.level = level;\n        }\n        \n        public int getLevel() {\n            return level;\n        }\n        \n        public boolean isHigherThan(Priority other) {\n            return this.level > other.level;\n        }\n    }\n    \n    // ✅ CORRECT: Value object utilities\n    public static class ValueObjectUtils {\n        \n        // Helper for creating immutable copies of mutable collections\n        public static <T> java.util.List<T> immutableCopy(java.util.List<T> list) {\n            return list == null ? \n                java.util.Collections.emptyList() : \n                java.util.Collections.unmodifiableList(new java.util.ArrayList<>(list));\n        }\n        \n        // Helper for null-safe equals\n        public static boolean safeEquals(Object a, Object b) {\n            return Objects.equals(a, b);\n        }\n        \n        // Helper for null-safe hashCode\n        public static int safeHashCode(Object... objects) {\n            return Objects.hash(objects);\n        }\n        \n        // Helper for building toString\n        public static String buildToString(String className, Object... keyValuePairs) {\n            StringBuilder sb = new StringBuilder(className).append(\"{\");\n            for (int i = 0; i < keyValuePairs.length; i += 2) {\n                if (i > 0) sb.append(\", \");\n                sb.append(keyValuePairs[i]).append(\"=\").append(keyValuePairs[i + 1]);\n            }\n            return sb.append(\"}\").toString();\n        }\n    }\n}