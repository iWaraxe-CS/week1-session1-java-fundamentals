package com.coherentsolutions.session1.antipatterns.packages;

/**\n * PACKAGE ORGANIZATION EXAMPLES\n * \n * This class demonstrates the differences between C# namespace organization\n * and Java package organization.\n * \n * KEY DIFFERENCES:\n * 1. C# namespaces vs Java packages\n * 2. PascalCase vs lowercase\n * 3. File structure requirements\n * 4. Access modifiers and visibility\n * 5. Using/import statement differences\n * \n * COMMON MISTAKES C# DEVELOPERS MAKE:\n * - Using PascalCase in package names\n * - Not matching file structure to package structure\n * - Misunderstanding package-private access\n * - Trying to use C# using alias syntax\n */\npublic class PackageExample {\n    \n    public static void main(String[] args) {\n        demonstratePackageOrganization();\n    }\n    \n    public static void demonstratePackageOrganization() {\n        System.out.println(\"=== PACKAGE ORGANIZATION DEMO ===\");\n        \n        // Current package information\n        Package currentPackage = PackageExample.class.getPackage();\n        System.out.println(\"Current package: \" + currentPackage.getName());\n        \n        // ❌ C# NAMESPACE STYLE (WRONG IN JAVA):\n        // namespace Com.CoherentSolutions.Session1.AntiPatterns.Packages\n        // {\n        //     public class PackageExample\n        //     {\n        //         // C# code here\n        //     }\n        // }\n        \n        // ✅ JAVA PACKAGE STYLE (CORRECT):\n        // package com.coherentsolutions.session1.antipatterns.packages;\n        // public class PackageExample {\n        //     // Java code here\n        // }\n        \n        System.out.println(\"\\n=== PACKAGE NAMING CONVENTIONS ===\");\n        System.out.println(\"C# Namespace: Com.CoherentSolutions.Session1.AntiPatterns\");\n        System.out.println(\"Java Package: com.coherentsolutions.session1.antipatterns\");\n        System.out.println(\"\\nKey Differences:\");\n        System.out.println(\"1. C# uses PascalCase, Java uses lowercase\");\n        System.out.println(\"2. C# allows spaces in project names, Java doesn't\");\n        System.out.println(\"3. Java follows reverse domain naming convention\");\n        \n        System.out.println(\"\\n=== FILE STRUCTURE REQUIREMENTS ===\");\n        System.out.println(\"Java package MUST match directory structure:\");\n        System.out.println(\"Package: com.coherentsolutions.session1.antipatterns.packages\");\n        System.out.println(\"File: src/main/java/com/coherentsolutions/session1/antipatterns/packages/PackageExample.java\");\n        System.out.println(\"\\nC# namespace can be independent of folder structure\");\n        \n        System.out.println(\"\\n=== ACCESS MODIFIER DIFFERENCES ===\");\n        demonstrateAccessModifiers();\n        \n        System.out.println(\"\\n=== IMPORT STATEMENT DIFFERENCES ===\");\n        demonstrateImports();\n    }\n    \n    public static void demonstrateAccessModifiers() {\n        System.out.println(\"\\nACCESS MODIFIERS COMPARISON:\");\n        System.out.println(\"\\nC# Access Modifiers:\");\n        System.out.println(\"- public: Accessible everywhere\");\n        System.out.println(\"- private: Only within the same class\");\n        System.out.println(\"- protected: Class and subclasses\");\n        System.out.println(\"- internal: Same assembly\");\n        System.out.println(\"- protected internal: Assembly + subclasses\");\n        \n        System.out.println(\"\\nJava Access Modifiers:\");\n        System.out.println(\"- public: Accessible everywhere\");\n        System.out.println(\"- private: Only within the same class\");\n        System.out.println(\"- protected: Package + subclasses\");\n        System.out.println(\"- (package-private): Same package only\");\n        \n        System.out.println(\"\\nKEY DIFFERENCE:\");\n        System.out.println(\"Java has package-private (no modifier) instead of C# internal\");\n        System.out.println(\"Java protected includes package access\");\n    }\n    \n    public static void demonstrateImports() {\n        System.out.println(\"\\nIMPORT STATEMENT COMPARISON:\");\n        \n        System.out.println(\"\\nC# using statements:\");\n        System.out.println(\"using System;\");\n        System.out.println(\"using System.Collections.Generic;\");\n        System.out.println(\"using System.Linq;\");\n        System.out.println(\"using MyAlias = Some.Very.Long.Namespace.ClassName;\");\n        \n        System.out.println(\"\\nJava import statements:\");\n        System.out.println(\"import java.util.List;\");\n        System.out.println(\"import java.util.ArrayList;\");\n        System.out.println(\"import java.util.*; // Wildcard import\");\n        System.out.println(\"import static java.lang.Math.PI; // Static import\");\n        \n        System.out.println(\"\\nKEY DIFFERENCES:\");\n        System.out.println(\"1. Java doesn't have using aliases\");\n        System.out.println(\"2. Java has static imports for static members\");\n        System.out.println(\"3. Java wildcard imports (*) vs C# using directives\");\n        System.out.println(\"4. Java automatically imports java.lang.*\");\n    }\n    \n    // Examples of different access levels\n    public String publicField = \"Accessible everywhere\";\n    protected String protectedField = \"Package + subclasses\";\n    String packagePrivateField = \"Same package only\"; // No modifier = package-private\n    private String privateField = \"This class only\";\n    \n    public void publicMethod() {\n        System.out.println(\"Public method - accessible everywhere\");\n    }\n    \n    protected void protectedMethod() {\n        System.out.println(\"Protected method - package + subclasses\");\n    }\n    \n    void packagePrivateMethod() { // No modifier = package-private\n        System.out.println(\"Package-private method - same package only\");\n    }\n    \n    private void privateMethod() {\n        System.out.println(\"Private method - this class only\");\n    }\n    \n    // Static nested class to demonstrate package structure\n    public static class NestedExample {\n        public void demonstrateNesting() {\n            System.out.println(\"\\n=== NESTED CLASS ORGANIZATION ===\");\n            System.out.println(\"Nested classes in Java are similar to C#\");\n            System.out.println(\"Full name: \" + this.getClass().getName());\n        }\n    }\n    \n    // Examples of common package organization patterns\n    public static void demonstratePackagePatterns() {\n        System.out.println(\"\\n=== COMMON PACKAGE ORGANIZATION PATTERNS ===\");\n        \n        System.out.println(\"\\n1. LAYERED ARCHITECTURE:\");\n        System.out.println(\"com.company.project.controller\");\n        System.out.println(\"com.company.project.service\");\n        System.out.println(\"com.company.project.repository\");\n        System.out.println(\"com.company.project.domain\");\n        \n        System.out.println(\"\\n2. FEATURE-BASED ARCHITECTURE:\");\n        System.out.println(\"com.company.project.user\");\n        System.out.println(\"com.company.project.order\");\n        System.out.println(\"com.company.project.payment\");\n        System.out.println(\"com.company.project.notification\");\n        \n        System.out.println(\"\\n3. HEXAGONAL ARCHITECTURE:\");\n        System.out.println(\"com.company.project.domain\");\n        System.out.println(\"com.company.project.application\");\n        System.out.println(\"com.company.project.infrastructure\");\n        System.out.println(\"com.company.project.adapters\");\n        \n        System.out.println(\"\\n4. CLEAN ARCHITECTURE:\");\n        System.out.println(\"com.company.project.entities\");\n        System.out.println(\"com.company.project.usecases\");\n        System.out.println(\"com.company.project.adapters\");\n        System.out.println(\"com.company.project.frameworks\");\n    }\n    \n    // Examples of package naming best practices\n    public static void demonstrateNamingBestPractices() {\n        System.out.println(\"\\n=== PACKAGE NAMING BEST PRACTICES ===\");\n        \n        System.out.println(\"\\n✅ GOOD PACKAGE NAMES:\");\n        System.out.println(\"com.coherentsolutions.project.user\");\n        System.out.println(\"com.coherentsolutions.project.user.service\");\n        System.out.println(\"com.coherentsolutions.project.user.repository\");\n        System.out.println(\"com.coherentsolutions.project.common.utils\");\n        \n        System.out.println(\"\\n❌ BAD PACKAGE NAMES:\");\n        System.out.println(\"Com.CoherentSolutions.Project.User // PascalCase\");\n        System.out.println(\"com.coherentsolutions.project.User // Class name in package\");\n        System.out.println(\"com.coherentsolutions.project.utilities // Too verbose\");\n        System.out.println(\"com.company.proj.u // Too abbreviated\");\n        \n        System.out.println(\"\\nBEST PRACTICES:\");\n        System.out.println(\"1. Use lowercase letters only\");\n        System.out.println(\"2. Use reverse domain name convention\");\n        System.out.println(\"3. Use singular nouns (user, not users)\");\n        System.out.println(\"4. Keep package names short but meaningful\");\n        System.out.println(\"5. Avoid java.* and javax.* prefixes\");\n        System.out.println(\"6. Use meaningful hierarchy\");\n    }\n    \n    // Demonstrate package-private access\n    static class PackagePrivateExample {\n        // This class is only visible within the same package\n        String packageData = \"Only accessible within package\";\n        \n        void packageMethod() {\n            System.out.println(\"Package-private method\");\n        }\n    }\n}